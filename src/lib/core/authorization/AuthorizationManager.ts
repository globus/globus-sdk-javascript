import type IConfig from 'js-pkce/dist/IConfig';

import {
  Token,
  TokenResponse,
  getAuthorizationEndpoint,
  getTokenEndpoint,
  isGlobusAuthTokenResponse,
} from '../../services/auth/index.js';

import { createStorage, getStorage } from '../storage/index.js';
import { log } from '../logger.js';

import { Event } from './Event.js';
import { RedirectTransport } from './RedirectTransport.js';
import { TokenLookup } from './TokenLookup.js';

export type AuthorizationManagerConfiguration = {
  client_id: IConfig['client_id'];
  requested_scopes: IConfig['requested_scopes'];
  redirect_uri: IConfig['redirect_uri'];
};

export type WellFormedError = {
  code: string;
  message: string;
};

export function isErrorWellFormed(error: unknown): error is WellFormedError {
  return typeof error === 'object' && error !== null && 'code' in error && 'message' in error;
}

export type ConsentRequiredError = {
  code: 'ConsentRequired';
  required_scopes: string[];
  [key: string]: unknown;
};

export function isConsentRequiredError(error: unknown): error is ConsentRequiredError {
  return isErrorWellFormed(error) && error.code === 'ConsentRequired' && 'required_scopes' in error;
}

type AuthorizationRequirementsError = {
  authorization_parameters: {
    session_message: string;
    session_required_identities: string[];
    session_required_mfa: boolean;
    session_required_single_domain: string[];
  };
  [key: string]: unknown;
};

export function isAuthorizationRequirementsError(
  error: unknown,
): error is AuthorizationRequirementsError {
  return isErrorWellFormed(error) && 'authorization_parameters' in error;
}

/**
 * @experimental
 */
export class AuthorizationManager {
  #transport!: RedirectTransport;

  configuration: AuthorizationManagerConfiguration;

  #authenticated = false;

  /**
   * The `AuthorizationManager` is consdiered `authenticated` if it has a valid Globus Auth token.
   * It does not necessarily mean that it has a valid token for a specific resource server.
   */
  get authenticated() {
    return this.#authenticated;
  }

  /**
   * Set the authenticated state and emit the `authenticated` event.
   */
  set authenticated(value: boolean) {
    this.#authenticated = value;
    this.#emitAuthenticatedState();
  }

  tokens: TokenLookup;

  events = {
    /**
     * Emitted when the authenticated state changes.
     */
    authenticated: new Event<
      'authenticated',
      {
        /**
         * Whether the `AuthorizationManager` is authenticated.
         * @see {@link AuthorizationManager.authenticated}
         */
        isAuthenticated: boolean;
        token?: TokenResponse;
      }
    >('authenticated'),
    /**
     * Emitted when the user revokes their authentication.
     */
    revoke: new Event('revoke'),
  };

  constructor(configuration: AuthorizationManagerConfiguration) {
    /**
     * @todo Add support for passing in an alternative storage mechanism.
     */
    createStorage('localStorage');
    if (!configuration.client_id) {
      throw new Error('You must provide a `client_id` for your application.');
    }
    this.configuration = {
      ...configuration,
    };

    this.tokens = new TokenLookup({
      manager: this,
    });
    this.startSilentRenew();
  }

  startSilentRenew() {
    log('debug', 'AuthorizationManager.startSilentRenew');
    this.#bootstrapFromStorageState();
    // @todo Iterate through all tokens and refresh them.
  }

  hasGlobusAuthToken() {
    return this.getGlobusAuthToken() !== null;
  }

  getGlobusAuthToken() {
    const entry = getStorage().get(`${this.configuration.client_id}:auth.globus.org`);
    return entry ? JSON.parse(entry) : null;
  }

  async #bootstrapFromStorageState() {
    log('debug', 'AuthorizationManager.bootstrapFromStorageState');
    if (this.hasGlobusAuthToken()) {
      log('debug', 'AuthorizationManager.bootstrapFromStorageState: hasGlobusAuthToken');
      this.authenticated = true;
    }
  }

  async #emitAuthenticatedState() {
    const isAuthenticated = this.authenticated;
    const token = this.getGlobusAuthToken() ?? undefined;
    await this.events.authenticated.dispatch({
      isAuthenticated,
      token,
    });
  }

  /**
   * Reset the authenticated state and clear all tokens from storage.
   */
  reset() {
    this.authenticated = false;
    /**
     * @todo This should be made specific to the keys generated by the `AuthorizationManager`.
     */
    getStorage().clear();
  }

  #buildTransport(overrides?: Partial<ConstructorParameters<typeof RedirectTransport>[0]>) {
    return new RedirectTransport({
      client_id: this.configuration.client_id,
      authorization_endpoint: getAuthorizationEndpoint(),
      token_endpoint: getTokenEndpoint(),
      redirect_uri: this.configuration.redirect_uri,
      requested_scopes: this.configuration.requested_scopes,
      ...overrides,
    });
  }

  /**
   * Initiate the login process by redirecting to the Globus Auth login page.
   */
  login() {
    this.reset();
    /**
     * In the future, it's possible that we may want to support different types of transports.
     */
    const transport = this.#buildTransport();
    transport.send();
  }

  async handleCodeRedirect() {
    const response = await this.#buildTransport().getToken();
    if (isGlobusAuthTokenResponse(response)) {
      this.addTokenResponse(response);
      this.authenticated = true;
    }
  }

  /**
   * @todo
   */
  handleErrorResponse(response: { code: unknown; required_scopes?: unknown }, execute = true) {
    let handler = () => {};

    if (isAuthorizationRequirementsError(response)) {
      handler = () => this.handleAuthorizationRequirementsError(response);
    }

    if (isConsentRequiredError(response)) {
      handler = () => this.handleConsentRequiredError(response);
    }

    if (response.code === 'AuthenticationFailed') {
      this.revoke();
    }
    return execute ? handler() : handler;
  }

  handleAuthorizationRequirementsError(response: AuthorizationRequirementsError) {
    this.#transport = this.#buildTransport({
      params: {
        session_message: response.authorization_parameters.session_message,
        session_required_identities:
          response.authorization_parameters.session_required_identities.join(','),
        session_required_mfa: response.authorization_parameters.session_required_mfa,
        session_required_single_domain:
          response.authorization_parameters.session_required_single_domain.join(','),
        prompt: 'login',
      },
    });
    this.#transport.send();
  }

  handleConsentRequiredError(response: ConsentRequiredError) {
    this.#transport = this.#buildTransport({
      requested_scopes: response.required_scopes.join(' '),
    });
    this.#transport.send();
  }

  /**
   * Add a Globus Auth token response to storage, if `other_tokens` are present they are also added.
   * This method is mostly used internally by the `AuthorizationManager`, but can be used by downstream
   * consumers to add tokens to storage if necessary.
   */
  addTokenResponse = (token: Token | TokenResponse) => {
    getStorage().set(`${this.configuration.client_id}:${token.resource_server}`, token);
    if ('other_tokens' in token) {
      token.other_tokens.forEach(this.addTokenResponse);
    }
  };

  async revoke() {
    this.reset();
    await this.events.revoke.dispatch();
  }
}
